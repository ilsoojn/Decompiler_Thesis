
{-************************************************************************
                          Function & Basic Block
  ************************************************************************-}

blockInfo :: [String] -> [String] -> String -> [(String, String)] -> [(String, String)]
blockInfo preContent (line:nextContent) name info
  | (is_RegexMatch regexEnd_fn line) = info ++ [(name, last preContent)] -- End Function
  | (is_RegexMatch regexInit_bb line) = do
    let newBlock = "bb_" ++ (get_RegexMatch regexInit_bb line)
        newInfo = info ++ [(name, last preContent)]
    blockInfo (preContent ++ [line]) nextContent newBlock newInfo
  | otherwise = blockInfo (preContent ++ [line]) nextContent name info

blockInfoBegin preContent (line:nextContent) = do
  if (is_RegexMatch regexInit_bb line)
    then blockInfo (preContent ++ [line]) nextContent ("bb_" ++ (get_RegexMatch regexInit_bb line)) []
    else blockInfoBegin (preContent ++ [line]) nextContent
--
-- functionInfo:: [String] -> [Function] -> [Function]
-- functionInfo [] info = info
-- functionInfo (line:content) info
--   | (isInfixOf start_fn line) = do
--     let fname = "fn_" ++ (get_RegexMatch regexInit_fn line)
--     functionInfo content (info ++ [Function fname (blockInfoBegin [] content)])
--   | (isRHS line fname) = do
--       let s = statement (strip line) fname
--           v = fromJust (fst s)
--           x = fst (snd s)
--       if (isCatchSwitch x)
--         then do
--           addVariable v "cs"
--
--   | otherwise = functionInfo content info


{-************************************************************************
                            BackTracking
  *************************************************************************-}
--
-- backtrackList :: String -> [String] -> [String] -> [(String, VAR)] -> [(String, VAR)]
-- backtrackList fname [] content stack = stack
-- backtrackList fname (v:vs) content stack = do
--   backtrackList fname vs content $ backtrack fname v content stack
--
-- backtrack :: String -> String -> [String] -> [(String, VAR)] -> [(String, VAR)]
-- backtrack fname v content stack
--   | (isInfixOf start_fn $ last content) = (stack) -- ++ (head $ last stack))
--   | not.null $ unwords $ map (head.tail) ((dropWhile isSpace $ last content) =~ (v ++ " = (.*)") :: [[String]]) = do
--     let (lhs, rhs) = strSplit'" = " $ last content
--         op = head $ words rhs
--     if isInfixOf "%RSP" $ last content
--       then do
--         let (rsp_v, idx) = strSplit ", " (last content)
--         stack ++ [(strip v, RSP fname (last $ words rsp_v) idx)]
--       else
--         case op of
--           "load" -> stack ++ [(strip lhs, loadStatement rhs fname)]
--           "alloca" -> stack ++ [(strip lhs, allocaStatement rhs fname)]
--           _ -> do
--             let parse_s = parseStatement (strip lhs) rhs -- Def(v) <- conversion/computation
--                 new_stck = bool (stack ++ [(v, fst parse_s)]) (stack ++ [(v, Other)]) (isConv $ fst parse_s)
--                 vList = getSSAssignValues (snd parse_s)
--             backtrackList fname vList (init content) new_stck
--   | otherwise = backtrack fname v (init content) stack -- not Def(v); maybe Use(v) but it doesn't matter
--
-- strVaraible :: [(String, VAR)] -> String -> [String] -> [(String, VAR)]
-- strVaraible (v:vs) fname content
--   | isConst(snd v) = [v]
--   | otherwise = backtrack fname (fst v) content []
--
-- findInstr :: [String] -> String -> [String] -> [STORE] -> [STORE]
-- findInstr [] fname content stack = stack
-- findInstr (line:nextLine) fname pre_content stack = do
--   if isInfixOf "store" line
--     then do
--       -- Extract value and location variables from the the IR 'store' format
--       -- store [...] <type> <value>, <type ptr> <location ptr> [, ...]
--       let s = storeStatement line     -- statement
--           v = strVaraible (str_v s) fname pre_content  -- store variable
--           at = backtrack fname (fst $ head $ str_at s) pre_content []  -- store location
--
--           -- update statement info and add to the STORE stack
--           -- new_s = s{str_v = v, str_at = at}
--           new_s = s{str_v = v, str_at = at}
--           new_stack = stack ++ [new_s]
--
--       findInstr nextLine fname (pre_content ++ [line]) new_stack
--
--     else if isInfixOf start_fn line
--       then do
--         let fnum = unwords $ map (head.tail) (line =~ regexInit_fn :: [[String]])
--             new_fname = "@fn_" ++ fnum
--         findInstr nextLine new_fname (pre_content ++ [line]) stack
--       else findInstr nextLine fname (pre_content ++ [line]) stack
